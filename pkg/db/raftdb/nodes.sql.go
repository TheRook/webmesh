// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: nodes.sql

package raftdb

import (
	"context"
	"database/sql"
	"time"
)

const assignNodeASN = `-- name: AssignNodeASN :one
INSERT INTO asns (node_id) VALUES (?) RETURNING asn, node_id, created_at
`

func (q *Queries) AssignNodeASN(ctx context.Context, nodeID string) (Asn, error) {
	row := q.db.QueryRowContext(ctx, assignNodeASN, nodeID)
	var i Asn
	err := row.Scan(&i.Asn, &i.NodeID, &i.CreatedAt)
	return i, err
}

const createNode = `-- name: CreateNode :one
INSERT INTO nodes (
    id,
    public_key,
    endpoint,
    available_zones,
    allowed_ips,
    network_ipv6,
    grpc_port,
    raft_port
) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, public_key, raft_port, grpc_port, endpoint, network_ipv6, allowed_ips, available_zones, created_at, updated_at
`

type CreateNodeParams struct {
	ID             string         `json:"id"`
	PublicKey      sql.NullString `json:"public_key"`
	Endpoint       sql.NullString `json:"endpoint"`
	AvailableZones sql.NullString `json:"available_zones"`
	AllowedIps     sql.NullString `json:"allowed_ips"`
	NetworkIpv6    sql.NullString `json:"network_ipv6"`
	GrpcPort       int64          `json:"grpc_port"`
	RaftPort       int64          `json:"raft_port"`
}

func (q *Queries) CreateNode(ctx context.Context, arg CreateNodeParams) (Node, error) {
	row := q.db.QueryRowContext(ctx, createNode,
		arg.ID,
		arg.PublicKey,
		arg.Endpoint,
		arg.AvailableZones,
		arg.AllowedIps,
		arg.NetworkIpv6,
		arg.GrpcPort,
		arg.RaftPort,
	)
	var i Node
	err := row.Scan(
		&i.ID,
		&i.PublicKey,
		&i.RaftPort,
		&i.GrpcPort,
		&i.Endpoint,
		&i.NetworkIpv6,
		&i.AllowedIps,
		&i.AvailableZones,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getNode = `-- name: GetNode :one
SELECT
    nodes.id AS id,
    nodes.public_key AS public_key,
    nodes.endpoint AS endpoint,
    nodes.allowed_ips AS allowed_ips,
    nodes.available_zones AS available_zones,
    nodes.grpc_port AS grpc_port,
    nodes.raft_port AS raft_port,
    nodes.network_ipv6 AS network_ipv6,
    COALESCE(asns.asn, 0) AS asn,
    COALESCE(leases.ipv4, '') AS private_address_v4,
    nodes.updated_at AS updated_at,
    nodes.created_at AS created_at
FROM nodes 
LEFT OUTER JOIN leases ON nodes.id = leases.node_id
LEFT OUTER JOIN asns ON nodes.id = asns.node_id
WHERE nodes.id = ?
`

type GetNodeRow struct {
	ID               string         `json:"id"`
	PublicKey        sql.NullString `json:"public_key"`
	Endpoint         sql.NullString `json:"endpoint"`
	AllowedIps       sql.NullString `json:"allowed_ips"`
	AvailableZones   sql.NullString `json:"available_zones"`
	GrpcPort         int64          `json:"grpc_port"`
	RaftPort         int64          `json:"raft_port"`
	NetworkIpv6      sql.NullString `json:"network_ipv6"`
	Asn              int64          `json:"asn"`
	PrivateAddressV4 string         `json:"private_address_v4"`
	UpdatedAt        time.Time      `json:"updated_at"`
	CreatedAt        time.Time      `json:"created_at"`
}

func (q *Queries) GetNode(ctx context.Context, id string) (GetNodeRow, error) {
	row := q.db.QueryRowContext(ctx, getNode, id)
	var i GetNodeRow
	err := row.Scan(
		&i.ID,
		&i.PublicKey,
		&i.Endpoint,
		&i.AllowedIps,
		&i.AvailableZones,
		&i.GrpcPort,
		&i.RaftPort,
		&i.NetworkIpv6,
		&i.Asn,
		&i.PrivateAddressV4,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getNodePeer = `-- name: GetNodePeer :one
SELECT
    nodes.id AS id,
    nodes.public_key AS public_key,
    COALESCE(asns.asn, 0) AS asn,
    nodes.endpoint AS endpoint,
    nodes.allowed_ips AS allowed_ips,
    nodes.grpc_port AS grpc_port,
    nodes.raft_port AS raft_port,
    nodes.network_ipv6 AS network_ipv6,
    COALESCE(leases.ipv4, '') AS private_address_v4
FROM nodes
LEFT OUTER JOIN leases ON nodes.id = leases.node_id
LEFT OUTER JOIN asns ON nodes.id = asns.node_id
WHERE nodes.id = ?
`

type GetNodePeerRow struct {
	ID               string         `json:"id"`
	PublicKey        sql.NullString `json:"public_key"`
	Asn              int64          `json:"asn"`
	Endpoint         sql.NullString `json:"endpoint"`
	AllowedIps       sql.NullString `json:"allowed_ips"`
	GrpcPort         int64          `json:"grpc_port"`
	RaftPort         int64          `json:"raft_port"`
	NetworkIpv6      sql.NullString `json:"network_ipv6"`
	PrivateAddressV4 string         `json:"private_address_v4"`
}

func (q *Queries) GetNodePeer(ctx context.Context, id string) (GetNodePeerRow, error) {
	row := q.db.QueryRowContext(ctx, getNodePeer, id)
	var i GetNodePeerRow
	err := row.Scan(
		&i.ID,
		&i.PublicKey,
		&i.Asn,
		&i.Endpoint,
		&i.AllowedIps,
		&i.GrpcPort,
		&i.RaftPort,
		&i.NetworkIpv6,
		&i.PrivateAddressV4,
	)
	return i, err
}

const getNodePrivateRPCAddress = `-- name: GetNodePrivateRPCAddress :one
SELECT node_id, address, port FROM node_rpc_addresses WHERE node_id = ?
`

func (q *Queries) GetNodePrivateRPCAddress(ctx context.Context, nodeID string) (NodeRpcAddress, error) {
	row := q.db.QueryRowContext(ctx, getNodePrivateRPCAddress, nodeID)
	var i NodeRpcAddress
	err := row.Scan(&i.NodeID, &i.Address, &i.Port)
	return i, err
}

const listNodePeers = `-- name: ListNodePeers :many
SELECT
    nodes.id AS id,
    nodes.public_key AS public_key,
    COALESCE(asns.asn, 0) AS asn,
    nodes.endpoint AS endpoint,
    nodes.allowed_ips AS allowed_ips,
    nodes.available_zones AS available_zones,
    nodes.grpc_port AS grpc_port,
    nodes.raft_port AS raft_port,
    nodes.network_ipv6 AS network_ipv6,
    nodes.updated_at AS updated_at,
    nodes.created_at AS created_at,
    COALESCE(leases.ipv4, '') AS private_address_v4
FROM nodes
LEFT OUTER JOIN leases ON nodes.id = leases.node_id
LEFT OUTER JOIN asns ON nodes.id = asns.node_id
WHERE nodes.id <> ?
`

type ListNodePeersRow struct {
	ID               string         `json:"id"`
	PublicKey        sql.NullString `json:"public_key"`
	Asn              int64          `json:"asn"`
	Endpoint         sql.NullString `json:"endpoint"`
	AllowedIps       sql.NullString `json:"allowed_ips"`
	AvailableZones   sql.NullString `json:"available_zones"`
	GrpcPort         int64          `json:"grpc_port"`
	RaftPort         int64          `json:"raft_port"`
	NetworkIpv6      sql.NullString `json:"network_ipv6"`
	UpdatedAt        time.Time      `json:"updated_at"`
	CreatedAt        time.Time      `json:"created_at"`
	PrivateAddressV4 string         `json:"private_address_v4"`
}

func (q *Queries) ListNodePeers(ctx context.Context, id string) ([]ListNodePeersRow, error) {
	rows, err := q.db.QueryContext(ctx, listNodePeers, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListNodePeersRow
	for rows.Next() {
		var i ListNodePeersRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicKey,
			&i.Asn,
			&i.Endpoint,
			&i.AllowedIps,
			&i.AvailableZones,
			&i.GrpcPort,
			&i.RaftPort,
			&i.NetworkIpv6,
			&i.UpdatedAt,
			&i.CreatedAt,
			&i.PrivateAddressV4,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNodes = `-- name: ListNodes :many
SELECT
    nodes.id AS id,
    nodes.public_key AS public_key,
    nodes.endpoint AS endpoint,
    nodes.allowed_ips AS allowed_ips,
    nodes.available_zones AS available_zones,
    nodes.grpc_port AS grpc_port,
    nodes.raft_port AS raft_port,
    nodes.network_ipv6 AS network_ipv6,
    COALESCE(asns.asn, 0) AS asn,
    COALESCE(leases.ipv4, '') AS private_address_v4,
    nodes.updated_at AS updated_at,
    nodes.created_at AS created_at
FROM nodes 
LEFT OUTER JOIN leases ON nodes.id = leases.node_id
LEFT OUTER JOIN asns ON nodes.id = asns.node_id
`

type ListNodesRow struct {
	ID               string         `json:"id"`
	PublicKey        sql.NullString `json:"public_key"`
	Endpoint         sql.NullString `json:"endpoint"`
	AllowedIps       sql.NullString `json:"allowed_ips"`
	AvailableZones   sql.NullString `json:"available_zones"`
	GrpcPort         int64          `json:"grpc_port"`
	RaftPort         int64          `json:"raft_port"`
	NetworkIpv6      sql.NullString `json:"network_ipv6"`
	Asn              int64          `json:"asn"`
	PrivateAddressV4 string         `json:"private_address_v4"`
	UpdatedAt        time.Time      `json:"updated_at"`
	CreatedAt        time.Time      `json:"created_at"`
}

func (q *Queries) ListNodes(ctx context.Context) ([]ListNodesRow, error) {
	rows, err := q.db.QueryContext(ctx, listNodes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListNodesRow
	for rows.Next() {
		var i ListNodesRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicKey,
			&i.Endpoint,
			&i.AllowedIps,
			&i.AvailableZones,
			&i.GrpcPort,
			&i.RaftPort,
			&i.NetworkIpv6,
			&i.Asn,
			&i.PrivateAddressV4,
			&i.UpdatedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const unassignNodeASN = `-- name: UnassignNodeASN :exec
DELETE FROM asns WHERE node_id = ?
`

func (q *Queries) UnassignNodeASN(ctx context.Context, nodeID string) error {
	_, err := q.db.ExecContext(ctx, unassignNodeASN, nodeID)
	return err
}

const updateNode = `-- name: UpdateNode :one
UPDATE nodes SET
    public_key = ?,
    endpoint = ?,
    available_zones = ?,
    allowed_ips = ?,
    network_ipv6 = ?,
    grpc_port = ?,
    raft_port = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, public_key, raft_port, grpc_port, endpoint, network_ipv6, allowed_ips, available_zones, created_at, updated_at
`

type UpdateNodeParams struct {
	PublicKey      sql.NullString `json:"public_key"`
	Endpoint       sql.NullString `json:"endpoint"`
	AvailableZones sql.NullString `json:"available_zones"`
	AllowedIps     sql.NullString `json:"allowed_ips"`
	NetworkIpv6    sql.NullString `json:"network_ipv6"`
	GrpcPort       int64          `json:"grpc_port"`
	RaftPort       int64          `json:"raft_port"`
	ID             string         `json:"id"`
}

func (q *Queries) UpdateNode(ctx context.Context, arg UpdateNodeParams) (Node, error) {
	row := q.db.QueryRowContext(ctx, updateNode,
		arg.PublicKey,
		arg.Endpoint,
		arg.AvailableZones,
		arg.AllowedIps,
		arg.NetworkIpv6,
		arg.GrpcPort,
		arg.RaftPort,
		arg.ID,
	)
	var i Node
	err := row.Scan(
		&i.ID,
		&i.PublicKey,
		&i.RaftPort,
		&i.GrpcPort,
		&i.Endpoint,
		&i.NetworkIpv6,
		&i.AllowedIps,
		&i.AvailableZones,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
