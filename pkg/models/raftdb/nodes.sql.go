// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: nodes.sql

package raftdb

import (
	"context"
	"database/sql"
	"time"
)

const createNode = `-- name: CreateNode :one
INSERT INTO nodes (
    id,
    public_key,
    endpoint,
    network_ipv6,
    grpc_port,
    raft_port,
    wireguard_port,
    created_at,
    updated_at
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, public_key, raft_port, grpc_port, wireguard_port, endpoint, network_ipv6, created_at, updated_at
`

type CreateNodeParams struct {
	ID            string         `json:"id"`
	PublicKey     sql.NullString `json:"public_key"`
	Endpoint      sql.NullString `json:"endpoint"`
	NetworkIpv6   sql.NullString `json:"network_ipv6"`
	GrpcPort      int64          `json:"grpc_port"`
	RaftPort      int64          `json:"raft_port"`
	WireguardPort int64          `json:"wireguard_port"`
	CreatedAt     time.Time      `json:"created_at"`
	UpdatedAt     time.Time      `json:"updated_at"`
}

func (q *Queries) CreateNode(ctx context.Context, arg CreateNodeParams) (Node, error) {
	row := q.db.QueryRowContext(ctx, createNode,
		arg.ID,
		arg.PublicKey,
		arg.Endpoint,
		arg.NetworkIpv6,
		arg.GrpcPort,
		arg.RaftPort,
		arg.WireguardPort,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Node
	err := row.Scan(
		&i.ID,
		&i.PublicKey,
		&i.RaftPort,
		&i.GrpcPort,
		&i.WireguardPort,
		&i.Endpoint,
		&i.NetworkIpv6,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteNode = `-- name: DeleteNode :exec
DELETE FROM nodes WHERE id = ?
`

func (q *Queries) DeleteNode(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteNode, id)
	return err
}

const getNode = `-- name: GetNode :one
SELECT
    nodes.id AS id,
    nodes.public_key AS public_key,
    nodes.endpoint AS endpoint,
    nodes.grpc_port AS grpc_port,
    nodes.raft_port AS raft_port,
    nodes.wireguard_port AS wireguard_port,
    nodes.network_ipv6 AS network_ipv6,
    COALESCE(leases.ipv4, '') AS private_address_v4,
    nodes.updated_at AS updated_at,
    nodes.created_at AS created_at
FROM nodes 
LEFT OUTER JOIN leases ON nodes.id = leases.node_id
WHERE nodes.id = ?
`

type GetNodeRow struct {
	ID               string         `json:"id"`
	PublicKey        sql.NullString `json:"public_key"`
	Endpoint         sql.NullString `json:"endpoint"`
	GrpcPort         int64          `json:"grpc_port"`
	RaftPort         int64          `json:"raft_port"`
	WireguardPort    int64          `json:"wireguard_port"`
	NetworkIpv6      sql.NullString `json:"network_ipv6"`
	PrivateAddressV4 string         `json:"private_address_v4"`
	UpdatedAt        time.Time      `json:"updated_at"`
	CreatedAt        time.Time      `json:"created_at"`
}

func (q *Queries) GetNode(ctx context.Context, id string) (GetNodeRow, error) {
	row := q.db.QueryRowContext(ctx, getNode, id)
	var i GetNodeRow
	err := row.Scan(
		&i.ID,
		&i.PublicKey,
		&i.Endpoint,
		&i.GrpcPort,
		&i.RaftPort,
		&i.WireguardPort,
		&i.NetworkIpv6,
		&i.PrivateAddressV4,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getNodePeer = `-- name: GetNodePeer :one
SELECT
    nodes.id AS id,
    nodes.public_key AS public_key,
    nodes.endpoint AS endpoint,
    nodes.grpc_port AS grpc_port,
    nodes.raft_port AS raft_port,
    nodes.wireguard_port AS wireguard_port,
    nodes.network_ipv6 AS network_ipv6,
    COALESCE(leases.ipv4, '') AS private_address_v4
FROM nodes
LEFT OUTER JOIN leases ON nodes.id = leases.node_id
WHERE nodes.id = ?
`

type GetNodePeerRow struct {
	ID               string         `json:"id"`
	PublicKey        sql.NullString `json:"public_key"`
	Endpoint         sql.NullString `json:"endpoint"`
	GrpcPort         int64          `json:"grpc_port"`
	RaftPort         int64          `json:"raft_port"`
	WireguardPort    int64          `json:"wireguard_port"`
	NetworkIpv6      sql.NullString `json:"network_ipv6"`
	PrivateAddressV4 string         `json:"private_address_v4"`
}

func (q *Queries) GetNodePeer(ctx context.Context, id string) (GetNodePeerRow, error) {
	row := q.db.QueryRowContext(ctx, getNodePeer, id)
	var i GetNodePeerRow
	err := row.Scan(
		&i.ID,
		&i.PublicKey,
		&i.Endpoint,
		&i.GrpcPort,
		&i.RaftPort,
		&i.WireguardPort,
		&i.NetworkIpv6,
		&i.PrivateAddressV4,
	)
	return i, err
}

const getNodePrivateRPCAddress = `-- name: GetNodePrivateRPCAddress :one
SELECT CAST(address AS TEXT) FROM node_private_rpc_addresses WHERE node_id = ?
`

func (q *Queries) GetNodePrivateRPCAddress(ctx context.Context, nodeID string) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getNodePrivateRPCAddress, nodeID)
	var column_1 interface{}
	err := row.Scan(&column_1)
	return column_1, err
}

const getNodePrivateRPCAddresses = `-- name: GetNodePrivateRPCAddresses :many
SELECT CAST(address AS TEXT) FROM node_private_rpc_addresses WHERE node_id <> ?
`

func (q *Queries) GetNodePrivateRPCAddresses(ctx context.Context, nodeID string) ([]interface{}, error) {
	rows, err := q.db.QueryContext(ctx, getNodePrivateRPCAddresses, nodeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []interface{}
	for rows.Next() {
		var column_1 interface{}
		if err := rows.Scan(&column_1); err != nil {
			return nil, err
		}
		items = append(items, column_1)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNodePublicRPCAddress = `-- name: GetNodePublicRPCAddress :one
SELECT CAST(address AS TEXT) FROM node_public_rpc_addresses WHERE node_id = ?
`

func (q *Queries) GetNodePublicRPCAddress(ctx context.Context, nodeID string) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getNodePublicRPCAddress, nodeID)
	var column_1 interface{}
	err := row.Scan(&column_1)
	return column_1, err
}

const getNodePublicRPCAddresses = `-- name: GetNodePublicRPCAddresses :many
SELECT CAST(address AS TEXT) FROM node_public_rpc_addresses WHERE node_id <> ?
`

func (q *Queries) GetNodePublicRPCAddresses(ctx context.Context, nodeID string) ([]interface{}, error) {
	rows, err := q.db.QueryContext(ctx, getNodePublicRPCAddresses, nodeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []interface{}
	for rows.Next() {
		var column_1 interface{}
		if err := rows.Scan(&column_1); err != nil {
			return nil, err
		}
		items = append(items, column_1)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNodePeers = `-- name: ListNodePeers :many
SELECT
    nodes.id AS id,
    nodes.public_key AS public_key,
    nodes.endpoint AS endpoint,
    nodes.grpc_port AS grpc_port,
    nodes.raft_port AS raft_port,
    nodes.wireguard_port AS wireguard_port,
    nodes.network_ipv6 AS network_ipv6,
    nodes.updated_at AS updated_at,
    nodes.created_at AS created_at,
    COALESCE(leases.ipv4, '') AS private_address_v4
FROM nodes
LEFT OUTER JOIN leases ON nodes.id = leases.node_id
WHERE nodes.id <> ?
`

type ListNodePeersRow struct {
	ID               string         `json:"id"`
	PublicKey        sql.NullString `json:"public_key"`
	Endpoint         sql.NullString `json:"endpoint"`
	GrpcPort         int64          `json:"grpc_port"`
	RaftPort         int64          `json:"raft_port"`
	WireguardPort    int64          `json:"wireguard_port"`
	NetworkIpv6      sql.NullString `json:"network_ipv6"`
	UpdatedAt        time.Time      `json:"updated_at"`
	CreatedAt        time.Time      `json:"created_at"`
	PrivateAddressV4 string         `json:"private_address_v4"`
}

func (q *Queries) ListNodePeers(ctx context.Context, id string) ([]ListNodePeersRow, error) {
	rows, err := q.db.QueryContext(ctx, listNodePeers, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListNodePeersRow
	for rows.Next() {
		var i ListNodePeersRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicKey,
			&i.Endpoint,
			&i.GrpcPort,
			&i.RaftPort,
			&i.WireguardPort,
			&i.NetworkIpv6,
			&i.UpdatedAt,
			&i.CreatedAt,
			&i.PrivateAddressV4,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNodes = `-- name: ListNodes :many
SELECT
    nodes.id AS id,
    nodes.public_key AS public_key,
    nodes.endpoint AS endpoint,
    nodes.grpc_port AS grpc_port,
    nodes.raft_port AS raft_port,
    nodes.wireguard_port AS wireguard_port,
    nodes.network_ipv6 AS network_ipv6,
    COALESCE(leases.ipv4, '') AS private_address_v4,
    nodes.updated_at AS updated_at,
    nodes.created_at AS created_at
FROM nodes 
LEFT OUTER JOIN leases ON nodes.id = leases.node_id
`

type ListNodesRow struct {
	ID               string         `json:"id"`
	PublicKey        sql.NullString `json:"public_key"`
	Endpoint         sql.NullString `json:"endpoint"`
	GrpcPort         int64          `json:"grpc_port"`
	RaftPort         int64          `json:"raft_port"`
	WireguardPort    int64          `json:"wireguard_port"`
	NetworkIpv6      sql.NullString `json:"network_ipv6"`
	PrivateAddressV4 string         `json:"private_address_v4"`
	UpdatedAt        time.Time      `json:"updated_at"`
	CreatedAt        time.Time      `json:"created_at"`
}

func (q *Queries) ListNodes(ctx context.Context) ([]ListNodesRow, error) {
	rows, err := q.db.QueryContext(ctx, listNodes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListNodesRow
	for rows.Next() {
		var i ListNodesRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicKey,
			&i.Endpoint,
			&i.GrpcPort,
			&i.RaftPort,
			&i.WireguardPort,
			&i.NetworkIpv6,
			&i.PrivateAddressV4,
			&i.UpdatedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPublicRPCAddresses = `-- name: ListPublicRPCAddresses :many
SELECT node_id, CAST(address AS TEXT) FROM node_public_rpc_addresses
`

type ListPublicRPCAddressesRow struct {
	NodeID  string      `json:"node_id"`
	Column2 interface{} `json:"column_2"`
}

func (q *Queries) ListPublicRPCAddresses(ctx context.Context) ([]ListPublicRPCAddressesRow, error) {
	rows, err := q.db.QueryContext(ctx, listPublicRPCAddresses)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPublicRPCAddressesRow
	for rows.Next() {
		var i ListPublicRPCAddressesRow
		if err := rows.Scan(&i.NodeID, &i.Column2); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateNode = `-- name: UpdateNode :one
UPDATE nodes SET
    public_key = ?,
    endpoint = ?,
    network_ipv6 = ?,
    grpc_port = ?,
    raft_port = ?,
    wireguard_port = ?,
    updated_at = ?
WHERE id = ?
RETURNING id, public_key, raft_port, grpc_port, wireguard_port, endpoint, network_ipv6, created_at, updated_at
`

type UpdateNodeParams struct {
	PublicKey     sql.NullString `json:"public_key"`
	Endpoint      sql.NullString `json:"endpoint"`
	NetworkIpv6   sql.NullString `json:"network_ipv6"`
	GrpcPort      int64          `json:"grpc_port"`
	RaftPort      int64          `json:"raft_port"`
	WireguardPort int64          `json:"wireguard_port"`
	UpdatedAt     time.Time      `json:"updated_at"`
	ID            string         `json:"id"`
}

func (q *Queries) UpdateNode(ctx context.Context, arg UpdateNodeParams) (Node, error) {
	row := q.db.QueryRowContext(ctx, updateNode,
		arg.PublicKey,
		arg.Endpoint,
		arg.NetworkIpv6,
		arg.GrpcPort,
		arg.RaftPort,
		arg.WireguardPort,
		arg.UpdatedAt,
		arg.ID,
	)
	var i Node
	err := row.Scan(
		&i.ID,
		&i.PublicKey,
		&i.RaftPort,
		&i.GrpcPort,
		&i.WireguardPort,
		&i.Endpoint,
		&i.NetworkIpv6,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
