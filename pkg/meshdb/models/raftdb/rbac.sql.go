// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: rbac.sql

package raftdb

import (
	"context"
	"database/sql"
	"time"
)

const DeleteRole = `-- name: DeleteRole :exec
DELETE FROM roles WHERE name = ?
`

func (q *Queries) DeleteRole(ctx context.Context, name string) error {
	_, err := q.db.ExecContext(ctx, DeleteRole, name)
	return err
}

const DeleteRoleBinding = `-- name: DeleteRoleBinding :exec
DELETE FROM role_bindings WHERE name = ?
`

func (q *Queries) DeleteRoleBinding(ctx context.Context, name string) error {
	_, err := q.db.ExecContext(ctx, DeleteRoleBinding, name)
	return err
}

const GetRole = `-- name: GetRole :one
SELECT name, rules_json, created_at, updated_at FROM roles WHERE name = ?
`

func (q *Queries) GetRole(ctx context.Context, name string) (Role, error) {
	row := q.db.QueryRowContext(ctx, GetRole, name)
	var i Role
	err := row.Scan(
		&i.Name,
		&i.RulesJson,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetRoleBinding = `-- name: GetRoleBinding :one
SELECT name, role_name, node_ids, user_names, group_names, created_at, updated_at FROM role_bindings WHERE name = ?
`

func (q *Queries) GetRoleBinding(ctx context.Context, name string) (RoleBinding, error) {
	row := q.db.QueryRowContext(ctx, GetRoleBinding, name)
	var i RoleBinding
	err := row.Scan(
		&i.Name,
		&i.RoleName,
		&i.NodeIds,
		&i.UserNames,
		&i.GroupNames,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const ListBoundRolesForNode = `-- name: ListBoundRolesForNode :many
SELECT DISTINCT roles.name, roles.rules_json, roles.created_at, roles.updated_at FROM roles
JOIN role_bindings ON roles.name = role_bindings.role_name
LEFT OUTER JOIN groups ON role_bindings.group_names LIKE '%' || groups.name || '%'
WHERE 
    role_bindings.node_ids LIKE '%' || ? || '%' OR
    role_bindings.node_ids = '*' OR
    groups.nodes LIKE '%' || ? || '%'
`

type ListBoundRolesForNodeParams struct {
	NodeIds sql.NullString `json:"node_ids"`
	Nodes   sql.NullString `json:"nodes"`
}

func (q *Queries) ListBoundRolesForNode(ctx context.Context, arg ListBoundRolesForNodeParams) ([]Role, error) {
	rows, err := q.db.QueryContext(ctx, ListBoundRolesForNode, arg.NodeIds, arg.Nodes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Role
	for rows.Next() {
		var i Role
		if err := rows.Scan(
			&i.Name,
			&i.RulesJson,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListBoundRolesForUser = `-- name: ListBoundRolesForUser :many
SELECT DISTINCT roles.name, roles.rules_json, roles.created_at, roles.updated_at FROM roles
JOIN role_bindings ON roles.name = role_bindings.role_name
LEFT OUTER JOIN groups ON role_bindings.group_names LIKE '%' || groups.name || '%'
WHERE 
    role_bindings.user_names LIKE '%' || ? || '%' OR
    role_bindings.user_names = '*' OR
    groups.users LIKE '%' || ? || '%'
`

type ListBoundRolesForUserParams struct {
	UserNames sql.NullString `json:"user_names"`
	Users     sql.NullString `json:"users"`
}

func (q *Queries) ListBoundRolesForUser(ctx context.Context, arg ListBoundRolesForUserParams) ([]Role, error) {
	rows, err := q.db.QueryContext(ctx, ListBoundRolesForUser, arg.UserNames, arg.Users)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Role
	for rows.Next() {
		var i Role
		if err := rows.Scan(
			&i.Name,
			&i.RulesJson,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListRoleBindings = `-- name: ListRoleBindings :many
SELECT name, role_name, node_ids, user_names, group_names, created_at, updated_at FROM role_bindings
`

func (q *Queries) ListRoleBindings(ctx context.Context) ([]RoleBinding, error) {
	rows, err := q.db.QueryContext(ctx, ListRoleBindings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RoleBinding
	for rows.Next() {
		var i RoleBinding
		if err := rows.Scan(
			&i.Name,
			&i.RoleName,
			&i.NodeIds,
			&i.UserNames,
			&i.GroupNames,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListRoles = `-- name: ListRoles :many
SELECT name, rules_json, created_at, updated_at FROM roles
`

func (q *Queries) ListRoles(ctx context.Context) ([]Role, error) {
	rows, err := q.db.QueryContext(ctx, ListRoles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Role
	for rows.Next() {
		var i Role
		if err := rows.Scan(
			&i.Name,
			&i.RulesJson,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const PutRole = `-- name: PutRole :exec
INSERT INTO roles (
    name, 
    rules_json, 
    created_at, 
    updated_at
) VALUES (
    ?, ?, ?, ?
)
ON CONFLICT (name) DO UPDATE SET 
    rules_json = excluded.rules_json, 
    updated_at = excluded.updated_at
`

type PutRoleParams struct {
	Name      string    `json:"name"`
	RulesJson string    `json:"rules_json"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
}

func (q *Queries) PutRole(ctx context.Context, arg PutRoleParams) error {
	_, err := q.db.ExecContext(ctx, PutRole,
		arg.Name,
		arg.RulesJson,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const PutRoleBinding = `-- name: PutRoleBinding :exec
INSERT INTO role_bindings (
    name,
    role_name, 
    node_ids, 
    user_names,
    group_names,
    created_at, 
    updated_at
) VALUES (
    ?, ?, ?, ?, ?, ?, ?
)
ON CONFLICT (name) DO UPDATE SET 
    role_name = excluded.role_name, 
    node_ids = excluded.node_ids, 
    user_names = excluded.user_names, 
    group_names = excluded.group_names, 
    updated_at = excluded.updated_at
`

type PutRoleBindingParams struct {
	Name       string         `json:"name"`
	RoleName   string         `json:"role_name"`
	NodeIds    sql.NullString `json:"node_ids"`
	UserNames  sql.NullString `json:"user_names"`
	GroupNames sql.NullString `json:"group_names"`
	CreatedAt  time.Time      `json:"created_at"`
	UpdatedAt  time.Time      `json:"updated_at"`
}

func (q *Queries) PutRoleBinding(ctx context.Context, arg PutRoleBindingParams) error {
	_, err := q.db.ExecContext(ctx, PutRoleBinding,
		arg.Name,
		arg.RoleName,
		arg.NodeIds,
		arg.UserNames,
		arg.GroupNames,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}
